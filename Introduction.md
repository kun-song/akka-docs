# 简介

## Akka Streams 的背后驱动

如今互联网提供的服务中有很多流式数据的例子，例如下载、上传以及 P2P 数据传输等。将数据视为 *元素流* 而非 *一个整体* 非常有用，因为这种视角不但符合计算机发送、接收数据的方式（例如通过 TCP），而且当数据集过于巨大而无法一次处理完成时，只能以流式视角处理它们。我们将计算、分析任务分布在庞大的集群上，并称之为“大数据”，其中的核心理念即将数据以流的方式顺序“喂给”多个 CPU 进行处理。

也可以将 Actor 的工作方式视为流式处理：Actor 之间发送、接收消息，从而实现数据在不同位置的转换。我们发现要实现 Actor 之间的稳定流非常无聊，且容易出错，因为除发送、接收消息外，还需要防止缓冲区、邮箱等的溢出。另一个问题是 Actor 消息可能丢失，此时为防止接收端流出现空洞，必须重新发送消息。当处理固定类型的元素流时，目前 Actor 也无法提供良好的 static guarantee 以防止传输错误：可以提升该场景下的类型安全。

基于以上原因，我们决定将这些问题的解决方案打包为 Akka Streams API，目的是为流式处理，提供符合直觉、安全的设置方式，以便高效地使用流，避免 `OutOfMemoryErrors` 之类错误。为达到设计目标，Akka Streams 必须可以限制使用的缓冲区大小，且当消费者处理速度较慢时，可以降低生产者的速度，该特性被称为“反压”，是响应式宣言的核心理念。对用户而言，Akka Streams 的设计中已经集成了传播和响应反压的解决方案，用户无需关心这些问题，这也意味着 Akka Streams 可以与其他所有 Reactive Streams 实现（Reactive Streams 接口定义了实现间的协同 API，诸如 Akka Streams 之类的实现提供用户层 API）无缝集成。

### Akka Streams 与 Reactive Streams 的关系

Akka Streams API 与 Reactive Stream 接口完全解耦，Akka Streams 专注于数据流的转换，而 Reactive Stream 仅仅定义了在无损耗、缓冲和资源消耗的前提下，跨越异步边界移动数据的通用机制。

两者之间的关系是：Akka Streams 接口面向最终用户设计，而其内部实现则借助 Reactive Streams 接口在不同处理阶段之间传递数据。因此 Reactive Streams 接口与 Akka Streams API 之间并无相似性，这符合 Reactive Streams 项目的设计目标，即定义不同流实现之间相互协作的接口，而非面向最终用户的 API。

## How to read these docs

流式处理是一种与 Actor 模型、Future 组合完全不同的范式，因此在熟悉流相关工具、技术之前，值得花些时间仔细研究。为了达到最好效果，推荐按照如下方式学习本文档：

* 阅读 [快速开始]()，了解流的基本形式和能力；
* 自顶向下的学习者可能会想阅读 [Akka Streams 背后的设计原则]()；
* 自底向上的学习者可能更想阅读 [Streams Cookbook]()
* [stages overview] 全面讲述了内置的处理阶段；
* 其他章节既可以按顺序阅读，可以在前面 4 步中按需读取，它们每一章对一个专题进行深入讲解；
